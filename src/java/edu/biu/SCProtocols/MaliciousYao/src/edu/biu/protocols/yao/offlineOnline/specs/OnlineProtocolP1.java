package edu.biu.protocols.yao.offlineOnline.specs;

import java.io.IOException;
import java.util.ArrayList;

import javax.crypto.SecretKey;

import edu.biu.protocols.yao.common.KeyUtils;
//import edu.biu.protocols.yao.common.LogTimer;
import edu.biu.protocols.yao.offlineOnline.primitives.Bundle;
import edu.biu.protocols.yao.offlineOnline.primitives.CommitmentBundle;
import edu.biu.protocols.yao.offlineOnline.primitives.EvaluationPackage;
import edu.biu.protocols.yao.offlineOnline.primitives.ExecutionParameters;
import edu.biu.protocols.yao.primitives.CircuitInput;
import edu.biu.protocols.yao.primitives.CommunicationConfig;
import edu.biu.protocols.yao.primitives.CryptoPrimitives;
import edu.biu.scapi.circuits.encryption.MultiKeyEncryptionScheme;
import edu.biu.scapi.comm.Channel;
import edu.biu.scapi.comm.Protocol;
import edu.biu.scapi.comm.ProtocolInput;
import edu.biu.scapi.comm.ProtocolOutput;
import edu.biu.scapi.exceptions.InvalidInputException;
import edu.biu.scapi.interactiveMidProtocols.ByteArrayRandomValue;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCDecommitmentMessage;

/**
 * This class represents the first party in the online phase of Malicious Yao protocol. <P>
 * 
 * The full protocol specification is described in "Blazing Fast 2PC in the "Offline/Online Setting with Security for 
 * Malicious Adversaries" paper by Yehuda Lindell and Ben Riva, page 20 - FIGURE E.3 (The Online Stage).
 * 
 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Asaf Cohen)
 *
 */
public class OnlineProtocolP1 implements Protocol {
	private final CryptoPrimitives primitives;	//Contains some primitives object to use during the protocol. For example, hash function.
	private final Channel channel;				//Used to communicate between the parties.

	/* 
	 * The buckets to use in the online protocol.
	 * The buckets contain some circuits to evaluate.
	 */
	private final ArrayList<Bundle> mainBucket;	//Contain the main circuits (for ex. AES).		
	private final ArrayList<Bundle> crBucket;	//Contain the cheating recovery circuits.		
	
	private CircuitInput input;					//Input for the main circuits.	
	private byte[][] maskedX;					//The xor of the placement mask and the input for the circuit.
	private SecretKey proofOfCheating;			//Generated by p1 and sent to p2 in order to detect cheating.
	
	/**
	 * A constructor that sets the given parameters and initializes some inline members.
	 * @param mainExecution Contains some parameters regarding the execution of the main circuits.
	 * @param crExecution Contains some parameters regarding the execution of the cheating recovery circuits.
	 * @param primitives Contains some primitives object to use during the protocol.
	 * @param communication Configuration of communication between parties.
	 * @param mainBucket Contain the main circuits (for ex. AES).	
	 * @param crBucket Contain the cheating recovery circuits.	
	 */
	public OnlineProtocolP1(ExecutionParameters mainExecution, ExecutionParameters crExecution, CryptoPrimitives primitives, 
			CommunicationConfig communication, ArrayList<Bundle> mainBucket, ArrayList<Bundle> crBucket) {
		this.primitives = primitives;
		this.channel = communication.getChannels()[0];
		this.mainBucket = mainBucket;
		this.crBucket = crBucket;
		this.input = null;
		this.maskedX = new byte[mainBucket.size() > crBucket.size() ? mainBucket.size() : crBucket.size()][];
		this.proofOfCheating = primitives.getMultiKeyEncryptionScheme().generateKey(); // D
 	}

	/**
	 * Sets the input for the protocol.
	 * @param protocolInput The input for the circuit.
	 */
	public void start(ProtocolInput protocolInput) {
		if (!(protocolInput instanceof CircuitInput)) {
			throw new IllegalArgumentException("expected CircuitInput!");
		}
		this.input = (CircuitInput) protocolInput;
	}

	/**
	 * Executes the first side of the online protocol.<p>
	 * basically, it computes the main circuit and than the cheating recovery circuit.
	 */
	public void run() {
	//	LogTimer timer = new LogTimer("Evaluating Main circuit");
		try {
			//Compute the main circuits part.
			evaluateMainCircuit();
	//		timer.stop();
			
		//	timer.reset("Evaluating CR circuit");
			//Compute the cheating recovery circuits part.
			evaluateCheatingRecoveryCircuit();
		//	timer.stop();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Computes the main circuits part.
	 * 
	 * pseudo code:
	 * 1. Receive the requested input from p2
	 * 2. Send the commitment masks
	 * 3. Decommit of p2 input wires' keys
	 * 4. Send the xor of the placement mask with the input
	 * 5. Decommit of p1 input wires' keys
	 * 6. Select and encrypt proof to send to p2
	 * @throws IOException
	 */
	private void evaluateMainCircuit() throws IOException {
		
		//The time measuring is commented out in order to save time. 
		//The user always can print them in case he wants to see the protocol process.
		
//		LogTimer timer = new LogTimer("Receiving Y2");
		//Receive the input bits of p2 input wires.
		CircuitInput y2 = receiveY2();
	//	timer.stop();
		
		//This package will hold all the necessary things that should be sent to the other party.
		//This way, there will be one sending of a big message instead of many small messages. This saves time.
		EvaluationPackage mainPackage = new EvaluationPackage();
		
	//	timer.reset("sendCommitmentMasks");
		//Add to the evaluationPackage the commitment masks of every circuit in the bucket.
		sendCommitmentMasks(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("decommitY2InputKeys");
		//Add the decommitments of all Y2 inputs of every circuit in the bucket according to the given y2 input bits.
		decommitY2InputKeys(mainBucket, mainPackage, y2);
	//	timer.stop();
		
	//timer.reset("sendPlacementMasks");
		//Add
		sendPlacementMasks(mainBucket, mainPackage);
	//	timer.stop();
		
		//timer.reset("sendXInputKeys");
		//Add the decommitments of p1 inputs of every circuit in the bucket.
		sendXInputKeys(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("selectAndEncryptProof");
		try {
			selectAndXorProof(mainBucket, mainPackage);
		} catch (InvalidInputException e) {
			throw new IllegalStateException(e);
		}
	//	timer.stop();
	//	timer.reset("sendPackage");
		
		//Send the evaluation package (contains all the protocol messages) to p2.
		channel.send(mainPackage);
		//timer.stop();
	}
	
	/**
	 * Computes the cheating recovery circuits part.
	 * 
	 * pseudo code:
	 * 1. Receive the requested input from p2
	 * 2. Send the commitment masks
	 * 3. Decommit on p2 input wires' keys
	 * 4. Send the xor of the placement mask with the input
	 * 5. Decommit on p1 input wires' keys
	 * 6. Decommit on both output wires' keys
	 * @throws IOException
	 */
	private void evaluateCheatingRecoveryCircuit() throws IOException {
	//	LogTimer timer = new LogTimer("Receiving D2");
		CircuitInput d2 = receiveY2();
	//	timer.stop();
		
		//This package will hold all the necessary things that should be sent to the other party.
		//This way, there will be one sending of a big message instead of many small messages. This saves time.
		EvaluationPackage crPackage = new EvaluationPackage();
		
	//	timer.reset("sendCommitmentMasks");
		//Add to the evaluationPackage the commitment masks of every circuit in the bucket.
		sendCommitmentMasks(crBucket, crPackage);
	//	timer.stop();
		
		//timer.reset("decommitD2InputKeys");
		//Add the decommitments of all d2 inputs of every circuit in the bucket according to the given d2 input bits.
		decommitD2InputKeys(crBucket, crPackage, d2);
	//	timer.stop();
		
	//	timer.reset("sendPlacementMasks");
		sendPlacementMasks(crBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("sendXInputKeys");
		//Add the decommitments of p1 inputs of every circuit in the bucket.
		sendXInputKeys(crBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("decommitOutputKeys");
		//Adds the decommitments of the output keys of every circuit in the bucket.
		decommitOutputKeys(mainBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("sendPackage");
		//Send the evaluation package (contains all the protocol messages) to p2.
		channel.send(crPackage);
	
	//	timer.stop();
	}
	
	/**
	 * Receive the input bit of p2 input wires.
	 * @return the received bits.
	 * @throws IOException IN case of problem during the receiving.
	 */
	private CircuitInput receiveY2() throws IOException {
		//Receive y2 from the other side as a byte array.
		byte[] y2;
		try {
			y2 = (byte [])channel.receive();
		} catch (ClassNotFoundException e) {
			throw new IOException(e);
		}
		//Convert the bytes to a circuit input and return it.
		return CircuitInput.fromByteArray(y2);
	}
	
	/**
	 * Adds to the evaluationPackage the commitment masks of every circuit in the bucket.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 */
	private void sendCommitmentMasks(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage){
		//Create space to all commitment masks.
		int size = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		byte[] commitmentMask = new byte[size*bucket.size()]; 
		
		//Add the commitment mask of every circuit in the bucket to the array.
		for (int j = 0; j < bucket.size(); j++) {
			System.arraycopy(bucket.get(j).getCommitmentMask(), 0, commitmentMask, j*size, size);
		}
		
		//add all masks to the evaluation package.
		evaluationPackage.setCommitmentMask(commitmentMask);
	}

	/**
	 * Adds the decommitments of all Y2 inputs of every circuit in the bucket according to the given y2 input bits.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 * @param y2 Input bit for each p2 input wire.
	 */
	private void decommitY2InputKeys(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage, CircuitInput y2) {
		
		//Sending the decommitments will not be done by sending the decommitments object since this is not efficient.
		//Instead, the values in the decommitments are copied to a one - dimension array and sent that way.
		
		//Create space to all decommitment.
		int[] inputLabelsY2 = bucket.get(0).getInputLabelsY2();
		int keySize = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		int hashSize = primitives.getCryptographicHash().getHashedMsgSize();
		byte[] allDecommitmentsX = new byte[bucket.size()*inputLabelsY2.length*keySize];
		byte[] allDecommitmentsR = new byte[bucket.size()*inputLabelsY2.length*hashSize];
		
		//For every circuit in the bucket,
		for (int j = 0; j < bucket.size(); j++) {
			CommitmentBundle commitmentBundleY2 = bucket.get(j).getCommitmentsY2();
			//For each input wire, 
			for (int i = 0; i < inputLabelsY2.length; i++) {
				//Get the decommitment values (x and r) and copy then to the created array. 
				byte[] x = (byte[]) commitmentBundleY2.getDecommitment(i, y2.getNthBit(i)).getX();
				byte[] r = (byte[]) ((ByteArrayRandomValue) commitmentBundleY2.getDecommitment(i, y2.getNthBit(i)).getR()).getR();
				System.arraycopy(x, 0, allDecommitmentsX, keySize*(j*inputLabelsY2.length + i), keySize);
				System.arraycopy(r, 0, allDecommitmentsR, hashSize*(j*inputLabelsY2.length + i), hashSize);
			}
		}
		
		//Set the arrays to the evaluation package.
		evaluationPackage.setDecommitmentsToY2InputKeys(allDecommitmentsX, allDecommitmentsR);
	}
	
	/**
	 * Adds the decommitments of all D2 inputs of every circuit in the bucket according to the given d2 input bits.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 * @param d2 Input bit for each p2 input wire.
	 */
	private void decommitD2InputKeys(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage, CircuitInput d2) {
		// Since the real placement of the master key must be fixed when synthesizing the input keys
		// we cannot send the completion to D, but to D' (which is the master proof of cheating).
		// so D ^ D' = M, where M is the mask that we need to apply on d2.
		SecretKey masterProofOfCheating = bucket.get(0).getSecret(); // M
		SecretKey maskOnD2;
		try {
			maskOnD2 = KeyUtils.xorKeys(masterProofOfCheating, proofOfCheating); // D ^ M = D'
		} catch (InvalidInputException e) {
			throw new IllegalStateException(e);
		}
		CircuitInput maskOnD2Input = CircuitInput.fromSecretKey(maskOnD2);
		CircuitInput modifiedD2 = CircuitInput.fromByteArray(CircuitInput.xor(d2, maskOnD2Input));
		
		// This may reveal M, but in order to obtain M in future executions P2 must still know D (changes every execution).
		evaluationPackage.addMaskOnD2(maskOnD2Input.asByteArray());
		
		// reveal the input keys for d2 ^ D' 
		// if d2 = d1 ^ D:
		// d1 ^ d2 ^ D' = d1 ^ d1 ^ D ^ D ^ M = M
		decommitY2InputKeys(bucket, evaluationPackage, modifiedD2);
	}
	
	/**
	 * Adds to the evaluationPackage the placement masks of every circuit in the bucket.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 */
	private void sendPlacementMasks(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage) {
		//Create space to all placement masks.
		byte[] placementMask = new byte[bucket.size()*input.asByteArray().length];
		
		//Add the xor of the placement masks with the input of every circuit in the bucket to the array.
		for (int j = 0; j < bucket.size(); j++) {
			byte[] mask = bucket.get(j).getPlacementMask(); // m_j
			
			byte[] x = input.asByteArray(); // x
			maskedX[j] = new byte[x.length]; // x_j
			for (int i = 0; i < x.length; i++) {
				maskedX[j][i] = (byte) (x[i] ^ mask[i]);
			}
			System.arraycopy(maskedX[j], 0, placementMask, j*x.length, x.length);
		}
		
		//Set the array to the evaluation package.
		evaluationPackage.setPlacementMask(placementMask);
	}
	
	/**
	 * Adds the decommitments of p1 inputs of every circuit in the bucket.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 */
	private void sendXInputKeys(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage) {
		
		//Sending the decommitments will not be done by sending the decommitments object since this is not efficient.
		//Instead, the values in the decommitments are copied to a one - dimension array and sent that way.
				
		//Create space to all decommitment.
		int[] inputLabelsP1 = bucket.get(0).getInputLabelsX();
		
		int keySize = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		int hashSize = primitives.getCryptographicHash().getHashedMsgSize();
		
		byte[] allDecommitmentsX = new byte[bucket.size()*inputLabelsP1.length*keySize];
		byte[] allDecommitmentsR = new byte[bucket.size()*inputLabelsP1.length*hashSize];
		
		//For every circuit in the bucket,
		for (int j = 0; j < bucket.size(); j++) {
			CommitmentBundle commitments = bucket.get(j).getCommitmentsX();
			//For every input wire,
			for (int i = 0; i < inputLabelsP1.length; i++) {
				
				//Get the decommitment values (x and r) and copy then to the created array. 
				CmtCDecommitmentMessage decom = commitments.getDecommitment(i, maskedX[j][i]);
				System.arraycopy((byte[]) decom.getX(), 0, allDecommitmentsX, keySize*(j*inputLabelsP1.length + i), keySize);
				System.arraycopy((byte[]) ((ByteArrayRandomValue) decom.getR()).getR(), 0, allDecommitmentsR, hashSize*(j*inputLabelsP1.length + i), hashSize);	
			}
		}
		
		//Set the arrays to the evaluation package.
		evaluationPackage.setDecommitmentsToXInputKeys(allDecommitmentsX, allDecommitmentsR);
	}
	
	/**
	 * Xor each output wire with random values in order to encrypt the output keys.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 * @throws InvalidInputException
	 */
	private void selectAndXorProof(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage) throws InvalidInputException {
		
		MultiKeyEncryptionScheme mes = primitives.getMultiKeyEncryptionScheme();
		int[] outputLabels = bucket.get(0).getOutputLabels();
		SecretKey[] r = new SecretKey[outputLabels.length]; // R[v]
		SecretKey[] p = new SecretKey[outputLabels.length]; // plaintexts R[v] ^ D
		
		int keySize = mes.getCipherSize();
		
		byte[] xoredProof = new byte[outputLabels.length*bucket.size()*2*keySize];
		
		//Xor the output keys with R[v] and P[v].
		for (int v = 0; v < outputLabels.length; v++) {
			r[v] = mes.generateKey();
			p[v] = KeyUtils.xorKeys(r[v], proofOfCheating);
			
			for (int j = 0; j < bucket.size(); j++) {
				
				for (int i=0; i<keySize; i++){
					
					xoredProof[keySize*(v*bucket.size()*2 + j*2) + i] = (byte) (bucket.get(j).getOutputWires()[v*2*keySize + i] ^ r[v].getEncoded()[i]);
					xoredProof[keySize*(v*bucket.size()*2 + j*2 + 1) + i] = (byte) (bucket.get(j).getOutputWires()[(v*2+1)*keySize + i] ^ p[v].getEncoded()[i]);
				}
			}
		}
		
		//Set the xor result in the package to send to p2.
		evaluationPackage.setXoredProofOfCheating(xoredProof);
		
		// Send H(D)
		SecretKey hashedProof = KeyUtils.hashKey(proofOfCheating, primitives.getCryptographicHash(), primitives.getKeyDerivationFunction(), mes.getCipherSize());
		evaluationPackage.setHashedProofOfCheating(hashedProof.getEncoded());

	}
	
	/**
	 * Adds the decommitments of the output keys of every circuit in the bucket.
	 * @param bucket The bucket to use in the protocol.
	 * @param evaluationPackage The message that will be sent to p2.
	 */
	private void decommitOutputKeys(ArrayList<Bundle> bucket, EvaluationPackage evaluationPackage) {
		// Reveal D.
		evaluationPackage.addProofOfCheating(proofOfCheating.getEncoded());
		int[] outputLabels = bucket.get(0).getOutputLabels();
		
		//Sending the decommitments will not be done by sending the decommitments object since this is not efficient.
		//Instead, the values in the decommitments are copied to a one - dimension array and sent that way.
				
		//Create space to all decommitment.
		int keySize = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		int hashSize = primitives.getCryptographicHash().getHashedMsgSize();
		
		byte[] allDecommitmentsX = new byte[bucket.size()*keySize*outputLabels.length*2];
		byte[] allDecommitmentsR = new byte[bucket.size()*hashSize];
		
		// For each circuit in the bucket, get the decommitment and put it in the package.
		for (int j = 0; j < bucket.size(); j++) {
			CmtCDecommitmentMessage outputCommitments = bucket.get(j).getDecommitmentsOutputKeys();
			
			byte[] x = (byte[]) outputCommitments.getX();
			byte[] r = ((ByteArrayRandomValue) outputCommitments.getR()).getR();
					
			System.arraycopy(x, 0, allDecommitmentsX, keySize*outputLabels.length*2*j, keySize*outputLabels.length*2);
			System.arraycopy(r, 0, allDecommitmentsR, hashSize*j, hashSize);
				
		}
		
		//Set the arrays to the evaluation package.
		evaluationPackage.setDecommitmentsToOutputKeys(allDecommitmentsX, allDecommitmentsR);
	}

	/**
	 * Party one in the online protocol has no output. Return null. 
	 */
	public ProtocolOutput getOutput() {
		//There is no output.
		return null;
	}
}
