package edu.biu.protocols.yao.offlineOnline.specs;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import edu.biu.protocols.yao.common.BinaryUtils;
import edu.biu.protocols.yao.common.KeyUtils;
//import edu.biu.protocols.yao.common.LogTimer;
import edu.biu.protocols.yao.common.Preconditions;
import edu.biu.protocols.yao.offlineOnline.primitives.CommitmentBundle;
import edu.biu.protocols.yao.offlineOnline.primitives.EvaluationPackage;
import edu.biu.protocols.yao.offlineOnline.primitives.ExecutionParameters;
import edu.biu.protocols.yao.offlineOnline.primitives.LimitedBundle;
import edu.biu.protocols.yao.offlineOnline.subroutines.MajoriryComputeRoutine;
import edu.biu.protocols.yao.offlineOnline.subroutines.OnlineComputeRoutine;
import edu.biu.protocols.yao.primitives.CircuitEvaluationResult;
import edu.biu.protocols.yao.primitives.CircuitInput;
import edu.biu.protocols.yao.primitives.CircuitOutput;
import edu.biu.protocols.yao.primitives.CommunicationConfig;
import edu.biu.protocols.yao.primitives.CryptoPrimitives;
import edu.biu.protocols.yao.primitives.CutAndChooseSelection;
import edu.biu.protocols.yao.primitives.EvaluateAllSelectionBuilder;
import edu.biu.protocols.yao.primitives.Expector;
import edu.biu.protocols.yao.primitives.KProbeResistantMatrix;
import edu.biu.scapi.circuits.circuit.BooleanCircuit;
import edu.biu.scapi.circuits.circuit.Wire;
import edu.biu.scapi.circuits.fastGarbledCircuit.FastGarbledBooleanCircuit;
import edu.biu.scapi.circuits.garbledCircuit.GarbledTablesHolder;
import edu.biu.scapi.circuits.garbledCircuit.JustGarbledGarbledTablesHolder;
import edu.biu.scapi.comm.Channel;
import edu.biu.scapi.comm.Protocol;
import edu.biu.scapi.comm.ProtocolInput;
import edu.biu.scapi.comm.ProtocolOutput;
import edu.biu.scapi.exceptions.CheatAttemptException;
import edu.biu.scapi.exceptions.InvalidInputException;
import edu.biu.scapi.exceptions.NoSuchPartyException;
import edu.biu.scapi.exceptions.NotAllInputsSetException;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCCommitmentMsg;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCDecommitmentMessage;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCommitValue;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.simpleHash.CmtSimpleHashDecommitmentMessage;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.simpleHash.CmtSimpleHashReceiver;
import edu.biu.scapi.primitives.hash.CryptographicHash;

/**
 * This class represents the second party in the online phase of Malicious Yao protocol. <P>
 * 
 * The full protocol specification is described in "Blazing Fast 2PC in the "Offline/Online Setting with Security for 
 * Malicious Adversaries" paper by Yehuda Lindell and Ben Riva, page 20 - FIGURE E.3 (The Online Stage).
 * 
 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Asaf Cohen)
 *
 */
public class OnlineProtocolP2 implements Protocol {
	
	private final ExecutionParameters mainExecution;		// Parameters of the main circuit.
	private final ExecutionParameters crExecution;			// Parameters of the cheating recovery circuit.
	private final CmtSimpleHashReceiver cmtReceiver;		//The receiver of the commitment protocol used to verify the decommitments.
	private final Channel channel;							//Used to communicate between the parties.
	
	private final CryptoPrimitives primitives; 				//Contains some primitives object to use during the protocol. For example, hash function.
	private final int keyLength;							//The length of each secret key in bytes.
	
	OnlineComputeRoutine computeRoutine;					//The instance that computes the main circuit.
	/* 
	 * The buckets to use in the online protocol.
	 * The buckets contain some circuits to evaluate.
	 */
	private final ArrayList<LimitedBundle> mainBucket;		//Contain the main circuits (for ex. AES).		
	private final ArrayList<LimitedBundle> crBucket;		//Contain the cheating recovery circuits.
	private final KProbeResistantMatrix mainMatrix;			//The probe-resistant matrix used to restore the main circuit's keys.
	private final KProbeResistantMatrix crMatrix;			//The probe-resistant matrix used to restore the cheating recovery circuit's keys.
	
	private CircuitInput input;								//The input for the main circuit.
	
	/*
	 * The following members are received from p1 in order to detect cheating in the protocol.
	 */
	private SecretKey proofOfCheating;						//Generated by p1 and sent to p2 in order to detect cheating.
	private SecretKey hashedProof;							//The result of the hash function on the proof of cheating.
	private byte[][][][] proofCiphers;
	
	private CircuitEvaluationResult evaluationResult;		// Indicates if a cheating was caught or not.
	private byte[] mainOutput;								//The output of the main circuit.
	private byte[] crOutput;								//The output of the cheating recovery circuit.
	
	/*
	 * Native methods that do the computations in a native environment. 
	 * Most of the times the native environment has better performance than the java environment.
	 */
	
	/**
	 * Gets the keys and mask and xor each key with the mask.
	 * The result is placed in the keys array.
	 * @param keys The keys to xor with the mask. This content is changed during the method and the output is places here.
	 * @param mask The mask to use in order to xor each key.
	 * @param size The number of keys.
	 */
	private native void xorKeysWithMask(byte[] keys, byte[] mask, int size);		
	
	/**
	 * Gets two arrays of keys and xor them. 
	 * @param keys1 The first keys array to xor. 
	 * @param keys2 The second keys array to xor. 
	 * @param output The result of xoring the keys array.
	 * @param size The number of keys.
	 */
	private native void xorKeys(byte[] keys1, byte[] keys2, byte[] output, int size); 
	
	/**
	 * Checks that the given random values and committed values are indeed lead to the commitments values.
	 * @param comm The commitments values.
	 * @param r The random values used to commit.
	 * @param x The values to commit on.
	 * @return true if the commitments match the values and randoms; false, otherwise.
	 */
	private native boolean verifyDecommitment(byte[] comm, byte[] r, byte[] x);
		
	/**
	 * Constructor that sets the parameters. 
	 * @param mainExecution Parameters of the main circuit.
	 * @param crExecution Parameters of the cheating recovery circuit.
	 * @param primitives Contains the low level instances to use.
	 * @param communication Configuration of communication between parties.
	 * @param mainBucket Contain the main circuits (for ex. AES).	
	 * @param crBucket Contain the cheating recovery circuits.
	 * @param mainMatrix The probe-resistant matrix used to restore the main circuit's keys.
	 * @param crMatrix The probe-resistant matrix used to restore the cheating recovery circuit's keys.
	 */
	public OnlineProtocolP2(ExecutionParameters mainExecution, ExecutionParameters crExecution, CryptoPrimitives primitives, 
			CommunicationConfig communication, ArrayList<LimitedBundle> mainBucket, ArrayList<LimitedBundle> crBucket, 
			KProbeResistantMatrix mainMatrix, KProbeResistantMatrix crMatrix) {
		//Set and initialize the parameters.
		this.mainExecution = mainExecution;
		this.crExecution = crExecution;
		this.primitives = primitives;
		
		this.mainMatrix = mainMatrix;
		this.crMatrix = crMatrix;
		
		this.keyLength = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		
		this.channel = communication.getChannels()[0];
		CryptographicHash hash = primitives.getCryptographicHash();
		this.cmtReceiver = new CmtSimpleHashReceiver(channel, hash, hash.getHashedMsgSize()); 
		this.mainBucket = mainBucket;
		this.crBucket = crBucket;
		this.input = null;
	}

	/**
	 * Sets the input for the protocol.
	 * @param protocolInput The input for the circuit.
	 */
	public void start(ProtocolInput protocolInput) {
		if (!(protocolInput instanceof CircuitInput)) {
			throw new IllegalArgumentException("expected CircuitInput!");
		}
		this.input = (CircuitInput) protocolInput;
	}

	/**
	 * Executes the second party of the online protocol.<p>
	 * basically, it computes the main circuit and than the cheating recovery circuit.
	 */
	public void run() {
		//LogTimer timer = new LogTimer("Evaluating Main circuit");
		try {
			//Compute the main circuits part.
			evaluateMainCircuit();
			//timer.stop();
			
			//timer.reset("Evaluating CR circuit");
			//Compute the cheating recovery circuits part.
			evaluateCheatingRecoveryCircuit();
			//timer.stop();
		} catch (CheatAttemptException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} 
	}
	
	/**
	 * Computes the main circuits part.
	 * 
	 * pseudo code:
	 * 1. Receive the requested input from p2
	 * 2. Send the commitment masks
	 * 3. Decommit of p2 input wires' keys
	 * 4. Send the xor of the placement mask with the input
	 * 5. Decommit of p1 input wires' keys
	 * 6. Select and encrypt proof to send to p2
	 * @throws IOException
	 */
	private void evaluateMainCircuit() throws IOException  {
	//	LogTimer timer = new LogTimer("selectAndSendY2");
		byte[] y2 = selectAndSendY2(mainBucket, input);
	//	timer.stop();
		
	//	timer.reset("receivePackage");
		EvaluationPackage mainPackage = receivePackage();
	//	timer.stop();
		
	//	timer.reset("receiveCommitmentMasks");
		receiveCommitmentMasks(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("receiveAndVerifyY2InputKeys");
		receiveAndVerifyY2InputKeys(mainBucket, mainPackage, mainMatrix, y2);
		
	//	timer.stop();
		
	//	timer.reset("receivePlacementMasks");
		receivePlacementMasks(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("receiveAndVerifyXInputKeys");
		receiveAndVerifyXInputKeys(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("receiveEncryptedProof");
		receiveEncryptedProof(mainBucket, mainPackage);
	//	timer.stop();
		
	//	timer.reset("computeEvaluationCircuits");
		computeEvaluationCircuits(mainBucket);
		
	//timer.stop();
	}
	
	private void evaluateCheatingRecoveryCircuit() throws IOException {
	//	LogTimer timer = new LogTimer("selectAndSendD2");
		byte[] d2 = selectAndSendY2(crBucket, CircuitInput.fromSecretKey(proofOfCheating));
	//	timer.stop();
		
	//	timer.reset("receivePackage");
		EvaluationPackage crPackage = receivePackage();
	//	timer.stop();
		
	//	timer.reset("receiveCommitmentMasks");
		receiveCommitmentMasks(crBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("receiveAndVerifyD2InputKeys");
		receiveAndVerifyD2InputKeys(crBucket, crPackage, crMatrix, d2);
	//	timer.stop();
		
	//	timer.reset("receivePlacementMasks");
		receivePlacementMasks(crBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("receiveAndVerifyXInputKeys");
		receiveAndVerifyXInputKeys(crBucket, crPackage);
	//	timer.stop();
		
	//	timer.reset("receiveAndVerifyOutputKeys");
		receiveAndVerifyOutputKeys(mainBucket, crPackage);
	//timer.stop();
		
	//	timer.reset("computeCheatingRecoveryCircuit");
		computeCheatingRecoveryCircuit(crBucket);
		
	//	timer.stop();
	}
	
	/**
	 * Receives the package from p1. This package contain all the necessary messages during the protocol.
	 * This gives better performance than sending each message separately.
	 * @return The received message.
	 * @throws CheatAttemptException In case the received message is not an EvaluationPackage instance.
	 * @throws IOException If there as a problem during the communication.
	 */
	private EvaluationPackage receivePackage() throws CheatAttemptException, IOException {
		Expector expector = new Expector(channel, EvaluationPackage.class);
		return (EvaluationPackage) expector.receive();
	}
	
	/**
	 * Computes the xor of the given input and the y1 keys that were generated in the offline protocol.
	 * Sends the result to the other party and returns it.
	 * @param bucket The bucket to work on.
	 * @param y The input for the circuit.
	 * @return The result of the xor of the given input and the y1 keys
	 * @throws IOException If there as a problem during the communication.
	 */
	private byte[] selectAndSendY2(ArrayList<LimitedBundle> bucket, CircuitInput y) throws IOException {
		
		//Xor the given input and the y1 keys that were generated in the offline protocol.
		byte[] y2 = CircuitInput.xor(y, bucket.get(0).getY1());
		
		//Send the result to p1.
		channel.send(y2);
		
		//Return the reault.
		return y2;
	}
	
	/**
	 * Extract the commitment mask of each circuit in the bucket from the received evaluationPackage and put it in the circuit.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 */
	private void receiveCommitmentMasks(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage)  {
		int size = primitives.getMultiKeyEncryptionScheme().getCipherSize();
		
		//For each circuit in the bucket, extract the commitment mask and set it in the circuit.
		for (int j = 0; j < bucket.size(); j++) {

			byte[] commitmentMask = new byte[size];
			System.arraycopy(evaluationPackage.getCommitmentMask(), j*size, commitmentMask, 0, size);
			bucket.get(j).setCommitmentMask(commitmentMask);
		}
	}
	
	/**
	 * Verifies that the received decommitments on the input keys are correct.
	 * In case they are, extract the keys and sets them in the circuits.
	 * In case the user enable threads, this function is split into the number of threads as the user requested.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 * @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	 * @param y2 The boolean input for the circuit.
	 */
	private void receiveAndVerifyY2InputKeys(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage, KProbeResistantMatrix matrix, byte[] y2) {
		//If the number of threads is more than zero, create the threads and assign to each one the appropriate circuits.
		if (primitives.getNumOfThreads() > 0){
			//In case the number of thread is less than the number of circuits in the bucket, there is no point to create all the threads.
			//In this case, create only number of threads as the bucket size and assign one circuit to each thread.
			int threadCount = (primitives.getNumOfThreads() < bucket.size()) ? primitives.getNumOfThreads() : bucket.size();
			VerifyY2InputKeysThread[] threads = new VerifyY2InputKeysThread[threadCount];
			
			//Calculate the number of circuit in each thread and the remainder.
			int remain = bucket.size() % threadCount;
			int numOfCircuits =  bucket.size() / threadCount;
			
			//Create the threads and assign to each one the appropriate circuits.
			//The last thread gets also the remaining circuits.
			for (int j = 0; j < threadCount; j++) {
				if ((j < (threadCount - 1)) || (remain == 0) ){
					threads[j] = new VerifyY2InputKeysThread(bucket, matrix, evaluationPackage, y2, j*numOfCircuits, (j+1)*numOfCircuits);
				} else {
					threads[j] = new VerifyY2InputKeysThread(bucket, matrix, evaluationPackage, y2, j*numOfCircuits, bucket.size());
				}
				//Start all threads.
				threads[j].start();
			}
			
			//Wait until all threads finish their job.
			for (int j = 0; j < threadCount; j++) {
				try {
					threads[j].join();
				} catch (InterruptedException e) {
					throw new IllegalStateException();
				}
			}
			
		//In case no thread should be created, verify all the circuits input directly.
		} else {
			verifyY2InputKeys(bucket, evaluationPackage, matrix, y2, 0, bucket.size());
		}
	}
	
	/**
	 * Verifies that the received decommitments on the input keys are correct.
	 * In case they are, extract the keys and sets them in the circuits.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 * @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	 * @param y2 The boolean input for the circuit.
	 * @param from The starting index in the bucket that point on the first circuit to work on.
	 * @param to The last index in the bucket that point on the last circuit to work on.
	 */
	private void verifyY2InputKeys(ArrayList<LimitedBundle> bucket,	EvaluationPackage evaluationPackage, 
			KProbeResistantMatrix matrix, byte[] y2, int from, int to) {
		//The labels are equal in all circuits.
		int[] inputLabelsY2 = bucket.get(0).getInputLabelsY2();
		int[] inputLabelsY1Extended = bucket.get(0).getInputLabelsY1Extended();
		
		int hashSize = primitives.getCryptographicHash().getHashedMsgSize();
		
		//For each circuit in the given range, verify the decommitment on the input keys.
		for (int k=from; k<to; k++){
			//Get the circuit, commitment mask and commitments on the keys.
			LimitedBundle circuitBundle = bucket.get(k);
			byte[] commitmentMask = circuitBundle.getCommitmentMask();
			CommitmentBundle commitmentBundleY2 = circuitBundle.getCommitmentsY2();
			
			//Get the extended keys generated in the offline phase.
			HashMap<Integer, SecretKey> inputKeysY1Extended = circuitBundle.getY1ExtendedInputKeys();
			
			//Copy the extended keys to a one dimension array in order to get better performance in the native implementation.
			int size = inputLabelsY1Extended.length;
			byte[] inputKeysY1ExtendedArray = new byte[keyLength*size];
			for (int i=0; i<size; i++){
				System.arraycopy(inputKeysY1Extended.get(inputLabelsY1Extended[i]).getEncoded(), 0, inputKeysY1ExtendedArray, keyLength*i, keyLength);
			}
			// Call the native method that xor the commitment mask with Y1 extended keys received in offline phase.
			xorKeysWithMask(inputKeysY1ExtendedArray, commitmentMask, size);
			
			//Restore the original y1 keys using the given probe resistant matrix and the result of xoring the commitment mask with Y1 extended keys.
			byte[] y1Keys = matrix.restoreKeys(inputKeysY1ExtendedArray);
		
			//Copy the commitments, values and random values to a one dimension array in order to get better performance in the native implementation.
			byte[] commitments = new byte[inputLabelsY2.length*hashSize];
			byte[] randoms = new byte[inputLabelsY2.length*hashSize];
			byte[] values = new byte[inputLabelsY2.length*keyLength];
			for (int i = 0; i < inputLabelsY2.length; i++) {
				CmtCDecommitmentMessage decom = evaluationPackage.getDecommitmentToY2InputKey(k, i, inputLabelsY2.length, keyLength, hashSize);
				CmtCCommitmentMsg com = commitmentBundleY2.getCommitment(i, y2[i]);
				
				System.arraycopy((byte[])com.getCommitment(), 0, commitments , i*hashSize, hashSize);
				System.arraycopy(((CmtSimpleHashDecommitmentMessage) decom).getR().getR(), 0, randoms , i*hashSize, hashSize);
				System.arraycopy((byte[])decom.getX(), 0, values , i*keyLength, keyLength);
			}
				
			//Checks that the random values and committed values are indeed lead to the commitments values.
			boolean valid = verifyDecommitment(commitments, randoms, values);
				
			//If the verify failed, there is a cheating. Throw an exception.
			if (valid == false) {
				throw new CheatAttemptException("incorrect decommitment!");
			}
		
			//Xor the keys with the commitment mask to get the y2 keys.
			xorKeysWithMask(values, commitmentMask, inputLabelsY2.length);
			
			//Xor y1 keys and y2 keys to get y keys.
			byte[] yKeys = new byte[inputLabelsY2.length*keyLength];
			xorKeys(values, y1Keys, yKeys, inputLabelsY2.length);
		
			//Set y keys to the circuit.
			circuitBundle.setYInputKeys(yKeys);
		
		}
	}
	
	/**
	 * Inner thread class that verifies that the received decommitments on the input keys are correct.
	 * 
	 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Moriya farbstein)
	 *
	 */
	private class VerifyY2InputKeysThread extends Thread{
		private ArrayList<LimitedBundle> bucket;		//The bucket to work on.
		private KProbeResistantMatrix matrix;			//The probe resistant matrix to use in order to restore the original keys from the extended keys.
		private EvaluationPackage evaluationPackage;	//The message that was received from p1.
		private byte[] y2;								//The boolean input for the circuit.
		private int from;								//The starting index in the bucket that point on the first circuit to work on.
		private int to;									//The last index in the bucket that point on the last circuit to work on.
		
		/**
		 * A constructor that sets the given parameters.
		 * @param bucket The bucket to work on.
		 * @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
		 * @param evaluationPackage The message that was received from p1.
		 * @param y2 The boolean input for the circuit.
		 * @param from The starting index in the bucket that point on the first circuit to work on.
		 * @param to The last index in the bucket that point on the last circuit to work on.
		 */
		public VerifyY2InputKeysThread(ArrayList<LimitedBundle> bucket, KProbeResistantMatrix matrix, 
				EvaluationPackage evaluationPackage, byte[] y2, int from, int to){
			this.bucket = bucket;
			this.matrix = matrix;
			this.evaluationPackage = evaluationPackage;
			this.y2 = y2;
			this.from = from;
			this.to = to;
		}
		
		/**
		 * Verifies that the received decommitments on the input keys are correct.
		 */
		public void run() {
			//Call the function that does the verification with the parameters.
			verifyY2InputKeys(bucket, evaluationPackage, matrix, y2, from, to);
		}
	}
	
	/**
	 * verifies that the received decommitments on the d2 input keys are correct.
	 * @param bucket The bucket to work on.
	 * @param matrix The probe resistant matrix to use in order to restore the original keys from the extended keys.
	 * @param evaluationPackage The message that was received from p1.
	 * @param d2 The boolean input for the cheating recovery circuit.
	 */
	private void receiveAndVerifyD2InputKeys(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage, KProbeResistantMatrix matrix, byte[] d2) {
		// Since the real placement of the master key must be fixed when synthesizing the input keys
		// we cannot send the completion to D, but to D' (which is the master proof of cheating).
		// so D ^ D' = M, where M is the mask that we need to apply on d2.
				
		byte[] maskOnD2 = evaluationPackage.getMaskOnD2();
		//Xor the inputs with the mask.
		byte[] modifiedD2 = new byte[d2.length];
		for (int i = 0; i < modifiedD2.length; i++) {
			modifiedD2[i] = (byte) (d2[i] ^ maskOnD2[i]);
		}
		
		//Call the function that verifies with the xor result.
		receiveAndVerifyY2InputKeys(bucket, evaluationPackage, matrix, modifiedD2);
	}
	
	/**
	 * Receive the placement mask and check that the difference is as expected.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 */
	private void receivePlacementMasks(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage) {

		int size = input.size();
		
		//For each circuit in the bucket, check the placement mask.
		for (int j = 0; j < bucket.size() - 1; j++) {
			
			//Get the circuit and its placement mask.
			LimitedBundle circuitBundle = bucket.get(j);
			
			byte[] currMask = new byte[size];
			byte[] nextMask = new byte[size];
			System.arraycopy(evaluationPackage.getPlacementMask(), j*size, currMask, 0, size);
			
			//Take the nest placement mask.
			System.arraycopy(evaluationPackage.getPlacementMask(), (j+1)*size, nextMask, 0, size);
	
			//compute the xor of both masks.
			byte[] actualDifference = new byte[currMask.length];
			for (int i = 0; i < actualDifference.length; i++) {
				actualDifference[i] = (byte) (currMask[i] ^ nextMask[i]);
			}
			
			//Get the value that was computed in the offline phase.
			byte[] committedDifference = circuitBundle.getPlacementMaskDifference();
			
			//If both values are not equal, this is a cheating. Throw a cheating exception.
			if (!Arrays.equals(committedDifference, actualDifference)) {
				throw new CheatAttemptException("committed delta between signals differ from actual signals!");
			}
		}
	}
	
	/**
	 * Verifies that the received decommitments on the x input keys are correct.
	 * In case they are, extract the keys and sets them in the circuits.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 */
	private void receiveAndVerifyXInputKeys(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage) {
		//The labels are equal in all circuits.
		int[] inputLabelsP1 = bucket.get(0).getInputLabelsX();
		int size = input.size();
		int hashSize = primitives.getCryptographicHash().getHashedMsgSize();
		
		//For each circuit, verify the decommitment on the input keys.
		for (int j = 0; j < bucket.size(); j++) {
			//Get the circuit, commitment mask and commitments on the keys.
			LimitedBundle circuitBundle = bucket.get(j);
			byte[] observedMask = new byte[size];
			System.arraycopy(evaluationPackage.getPlacementMask(), j*size, observedMask, 0, size);
			byte[] commitmentMask = circuitBundle.getCommitmentMask();
			CommitmentBundle commitments = circuitBundle.getCommitmentsX();
			
			//Copy the commitments, values and random values to a one dimension array in order to get better performance in the native implementation.
			byte[] commitmentsArray = new byte[inputLabelsP1.length*hashSize];
			byte[] randoms = new byte[inputLabelsP1.length*hashSize];
			byte[] values = new byte[inputLabelsP1.length*keyLength];
			
			for (int i = 0; i < inputLabelsP1.length; i++) {
				CmtCCommitmentMsg com = commitments.getCommitment(i, observedMask[i]);
				CmtCDecommitmentMessage decom = evaluationPackage.getDecommitmentToXInputKey(j, i, inputLabelsP1.length, keyLength, hashSize);
				
				System.arraycopy((byte[])com.getCommitment(), 0, commitmentsArray , i*hashSize, hashSize);
				System.arraycopy(((CmtSimpleHashDecommitmentMessage) decom).getR().getR(), 0, randoms , i*hashSize, hashSize);
				System.arraycopy((byte[])decom.getX(), 0, values , i*keyLength, keyLength);
			}
			
			//Checks that the random values and committed values are indeed lead to the commitments values.
			boolean valid = verifyDecommitment(commitmentsArray, randoms, values);
			
			//If the verify failed, there is a cheating. Throw an exception.
			if (valid == false) {
				throw new CheatAttemptException("incorrect decommitment!");
			}
			
			//Xor the keys with the commitment mask to get the x keys.
			xorKeysWithMask(values, commitmentMask, inputLabelsP1.length);
			
			//Set x keys to the circuit.
			circuitBundle.setXInputKeys(values);
		}
	}
	
	/**
	 * Extract from the received package the encrypted proof of cheating.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 */
	private void receiveEncryptedProof(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage)  {
		int[] outputLabels = bucket.get(0).getOutputLabels();
		proofCiphers = new byte[outputLabels.length][bucket.size()][2][];
		
		//For each output label and for each circuit, get the encrypted proofs.
		for (int v = 0; v < outputLabels.length; v++) {
			for (int j = 0; j < bucket.size(); j++) {
				for (int k = 0; k < 2; k++) {
					proofCiphers[v][j][k] = evaluationPackage.getXoredProof(v, j, k, bucket.size(), keyLength);
				}
			}
		}
		
		// receive H(D)
		hashedProof = new SecretKeySpec(evaluationPackage.getHashedProof(), "");
	}
	
	/**
	 * Computes the main circuit.
	 * @param bucket The bucket to work on.
	 */
	private void computeEvaluationCircuits(ArrayList<LimitedBundle> bucket)  {
		//Get the circuits to work on.
		FastGarbledBooleanCircuit[] garbledCircuits = mainExecution.getCircuits();
		
		//For each circuit, set the garbled table, translation table and inputs.
		for (int j = 0; j < bucket.size(); j++) {
			
			LimitedBundle circuitBundle = bucket.get(j);
			//Set the garbled and translation tables.
			garbledCircuits[j].setGarbledTables(circuitBundle.getGarbledTables());
			garbledCircuits[j].setTranslationTable(circuitBundle.getTranslationTable());
			
			//Copy the x and y inputs to one big inputs array.
			int[] inputIndices = garbledCircuits[j].getInputWireIndices();
			int numberOfInputs = inputIndices.length;
			byte[] inputs = new byte[keyLength*numberOfInputs];
			byte[] xInputs = circuitBundle.getXInputKeys();
			byte[] yInputs = circuitBundle.getYInputKeys();

			System.arraycopy(xInputs, 0, inputs, 0, xInputs.length);		
			System.arraycopy(yInputs, 0, inputs, xInputs.length, yInputs.length);
		
			//Set the inputs to the circuit.
			garbledCircuits[j].setInputs(inputs);	
		}
		
		//Create a compute routine.
		computeRoutine = new OnlineComputeRoutine(garbledCircuits, primitives, proofCiphers, hashedProof);
		//Computes the circuits.
		computeRoutine.computeCircuits();
		//Check if all circuits return the same output.
		evaluationResult = computeRoutine.runOutputAnalysis();
		
		//If found a proof of cheating, get it. Else, get a dummy key.
		proofOfCheating = computeRoutine.getProofOfCheating();
	}
	
	/**
	 * Verifies the decommitment on the output keys that were received from p1.
	 * @param bucket The bucket to work on.
	 * @param evaluationPackage The message that was received from p1.
	 */
	private void receiveAndVerifyOutputKeys(ArrayList<LimitedBundle> bucket, EvaluationPackage evaluationPackage) {
		
		//Get the proof of cheating. 
		SecretKey realProofOfCheating = new SecretKeySpec(evaluationPackage.getProofOfCheating(), "");
		
		//Compute the hash function on the proof of cheating and check that the result is equal to the given one.
		CryptographicHash hash = primitives.getCryptographicHash();
		SecretKey hashOfRealProof = KeyUtils.hashKey(realProofOfCheating, hash, primitives.getKeyDerivationFunction(), keyLength);
		if (!KeyUtils.compareKeys(hashOfRealProof, hashedProof)) {
			throw new CheatAttemptException("H(D) given previously does not equal H() on the decommitted D!");
		}
		
		int[] outputLabels = bucket.get(0).getOutputLabels();

		int correctCircuit = -1;
		//for each circuit in the bucket, 
		for (int j = 0; j < bucket.size(); j++) {
			boolean allOutputsAreCorrect = true;
			
			CmtCCommitmentMsg commitment = bucket.get(j).getCommitmentsOutputKeys();
		
			int hashSize = hash.getHashedMsgSize();
			//Get the decommitment values and verify them.
			CmtCDecommitmentMessage decom = evaluationPackage.getDecommitmentToOutputKey(j, outputLabels.length, keyLength, hashSize);
			CmtCommitValue kVal = cmtReceiver.verifyDecommitment(commitment, decom);
			
			//If the verify failed, there is a cheating. Throw an exception.
			if (null == kVal) {
				throw new CheatAttemptException("incorrect decommitment!");
			}
			
			//Generate a key from the decommitted value and xor it with the proof ciphers.
			byte[] decryptKey = cmtReceiver.generateBytesFromCommitValue(kVal);
			
			
			//For each output key, get the corresponding keys.
			for (int v = 0; v < outputLabels.length; v++) {
				byte[][] decryptions = new byte[2][];
				byte[][] keys = new byte[2][];
				for (int k = 0; k < 2; k++) {
		
					keys[k] = new byte[keyLength];
					decryptions[k] = new byte[keyLength];
					System.arraycopy(decryptKey, (v*2+k)*keyLength, keys[k], 0, keyLength);
					for (int i=0; i<keyLength; i++){
						decryptions[k][i] = (byte) (keys[k][i] ^ proofCiphers[v][j][k][i]);
					}		
				}
				
				allOutputsAreCorrect = checkCircuitOutputsFromCompute(keys, j, v);
				
				//Xor both result of the above decryptions.
				SecretKey result = null;
				try {
					result = KeyUtils.xorKeys(new SecretKeySpec(decryptions[0], ""), new SecretKeySpec(decryptions[1], ""));
				} catch (InvalidInputException e) {
					// Should not occur since both keys are output of the encryption scheme and have the same length
				}
				//Compare the result to the proof of cheating. In case they are not equal, throw a cheating exception.
				if (!KeyUtils.compareKeys(result, realProofOfCheating)) {
					throw new CheatAttemptException("the xor of the output keys does not give the real proof for label v = " + v);
				}
				
			}
			
			if (allOutputsAreCorrect){
				correctCircuit = j;
			} 
		}
		
		if (correctCircuit != -1){
			computeRoutine.setCorrectCircuit(correctCircuit);
			mainOutput = computeRoutine.getOutput();
		}
	}
	
	private boolean checkCircuitOutputsFromCompute(byte[][] keys, int circuitIndex, int wireIndex) {
		byte[] garbledOutput = computeRoutine.getComputedOutputWires(circuitIndex);
		byte[] key = new byte[keyLength];
		System.arraycopy(garbledOutput, wireIndex*keyLength, key, 0, keyLength);
		
		if (Arrays.equals(key, keys[0]) || Arrays.equals(key, keys[1])){
			return true;
		}
		return false;
	}

	/**
	 * Computes the cheating recovery circuit.
	 * @param bucket The bucket to work on.
	 */
	private void computeCheatingRecoveryCircuit(ArrayList<LimitedBundle> bucket) {
		//Get the circuits to work on.
		FastGarbledBooleanCircuit[] garbledCircuits = crExecution.getCircuits();
		
		//For each circuit, get the master key and set the garbled table, translation table and inputs.
		for (int j = 0; j < bucket.size(); j++) {
			LimitedBundle circuitBundle = bucket.get(j);
			
			//GEt the master key.
			byte[] masterKeyShares = circuitBundle.getYInputKeys();
			int[] secretSharingLabels = circuitBundle.getInputLabelsY2();
			
			byte[] masterKey = new byte[keyLength];
			System.arraycopy(masterKeyShares, 0, masterKey, 0, keyLength);
			//System.arraycopy(masterKeyShares, secretSharingLabels[0]*keyLength, masterKey, 0, keyLength);
			for (int i = 1; i < secretSharingLabels.length; i++) {
				byte[] temp = new byte[keyLength];
				System.arraycopy(masterKeyShares, i*keyLength, temp, 0, keyLength);
				try {
					masterKey = BinaryUtils.xorArrays(masterKey, temp);
				} catch (InvalidInputException e) {
					// Should not occur since both keys have the same length.
				}
			}
			
			//Set the garbled and translation tables.
			garbledCircuits[j].setGarbledTables(circuitBundle.getGarbledTables());
			garbledCircuits[j].setTranslationTable(circuitBundle.getTranslationTable());
			
			//Copy all inputs to one big inputs array.
			int[] inputIndices = garbledCircuits[j].getInputWireIndices();
			int numberOfInputs = inputIndices.length;
			byte[] inputs = new byte[keyLength*numberOfInputs];
			byte[] xInputs = circuitBundle.getXInputKeys();
			System.arraycopy(xInputs, 0, inputs, 0, xInputs.length);
			System.arraycopy(masterKey, 0, inputs, xInputs.length, keyLength);

			//Set the inputs to the circuit.
			garbledCircuits[j].setInputs(inputs);
		}
		
		//Create the majority comute routine.
		CutAndChooseSelection dummySelection = new EvaluateAllSelectionBuilder().build(bucket.size());
		MajoriryComputeRoutine computeRoutine = new MajoriryComputeRoutine(dummySelection, garbledCircuits,  primitives);
		
		//Computes the circuits.
		computeRoutine.computeCircuits();
		
		//get majority output.
		computeRoutine.runOutputAnalysis();
		
		//Get the majority output.
		crOutput = computeRoutine.getOutput();	
	}

	/**
	 * Get the output of the protocol.
	 */
	public ProtocolOutput getOutput() {
		BooleanCircuit bc = mainExecution.getBooleanCircuit();
		int[] outputLabels = bc.getOutputWireIndices();
		
		//In case the circuit computation returned valid output this is the output of the protocol and return it.
		if (evaluationResult == CircuitEvaluationResult.VALID_OUTPUT && mainOutput != null) {
			return new CircuitOutput(mainOutput);
		}
		
		// If we got here, cheating was detected. Therefore we must have obtained P1's input.
		Preconditions.checkNotNull(crOutput);
		
		// We must use the output received in the GoToCourt stage as the input of P1 to the UNGARBLED circuit.
		ArrayList<Integer> inputIndices = null;
		try {
			inputIndices = bc.getInputWireIndices(1);
		} catch (NoSuchPartyException e1) {
			// Should not occur since there is party number one.
		}
		
		//Create the input of p1 according to the cheating recovery output.
		Map<Integer, Wire> inputP1 = new HashMap<Integer, Wire>();
		for (int i=0; i<inputIndices.size(); i++){
			inputP1.put(inputIndices.get(i), new Wire(crOutput[i]));
		}
		
		//Get the input to p2 from the circuit input.
		Map<Integer, Wire> inputP2 = input.getInputWires();
		
		//Set the inputs.
		try {
			bc.setInputs(inputP1, 1);
			bc.setInputs(inputP2, 2);
		} catch (NoSuchPartyException e) {
			throw new IllegalStateException(e);
		}
		
		//Compute the boolean circuit
		Map<Integer, Wire> output = null;
		try {
			 output = bc.compute();
		} catch (NotAllInputsSetException e) {
			throw new IllegalStateException(e);
		}
		
		//Convert the output into a byte array.
		byte[] byteOutput = new byte[outputLabels.length];
		for (int i=0; i<outputLabels.length; i++){
			byteOutput[i] = output.get(outputLabels[i]).getValue();
		}
		
		//Create an output object using the converted array.
		return new CircuitOutput(byteOutput);
	}
}
